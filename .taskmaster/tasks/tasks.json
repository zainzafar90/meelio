{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Add isBlocked field to database schema",
        "description": "Create and run database migration to add the isBlocked boolean field to the site_blockers table with default value of true",
        "details": "1. Create migration file using Drizzle ORM\n2. Add column: isBlocked: boolean('is_blocked').notNull().default(true)\n3. Run migration in development and staging environments\n4. Update TypeScript types for SiteBlocker entity\n5. Ensure backward compatibility by handling null values during transition",
        "testStrategy": "1. Verify migration runs successfully without data loss\n2. Test that existing records get default value of true\n3. Confirm new records properly set isBlocked field\n4. Test rollback procedure\n5. Validate schema changes in database admin tool",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create database migration file for isBlocked field",
            "description": "Generate a new Drizzle ORM migration file that adds the isBlocked boolean column to the site_blockers table",
            "dependencies": [],
            "details": "Use Drizzle ORM's migration generator to create a migration file that adds 'isBlocked: boolean('is_blocked').notNull().default(true)' to the site_blockers table schema. Ensure the migration file follows the project's naming convention and is placed in the correct migrations directory.",
            "status": "done",
            "testStrategy": "Verify the migration file is syntactically correct, contains the proper SQL statements for adding the column with default value, and includes both up and down migration logic for rollback support"
          },
          {
            "id": 2,
            "title": "Update TypeScript schema and types",
            "description": "Modify the Drizzle schema definition and TypeScript types to include the new isBlocked field in the SiteBlocker entity",
            "dependencies": [
              "1.1"
            ],
            "details": "Update the Drizzle schema file to include the isBlocked column definition. Regenerate or manually update TypeScript types to ensure the SiteBlocker interface includes 'isBlocked: boolean'. Update any DTOs or API response types that reference SiteBlocker.",
            "status": "done",
            "testStrategy": "Run TypeScript compilation to ensure no type errors. Verify that all files importing SiteBlocker types compile successfully and IDE autocomplete shows the new isBlocked field"
          },
          {
            "id": 3,
            "title": "Execute migration in development environment",
            "description": "Run the database migration in the development environment and verify successful execution",
            "dependencies": [
              "1.1",
              "1.2"
            ],
            "details": "Execute the Drizzle migration command in the development environment. Verify that the migration runs without errors, the isBlocked column is added to the site_blockers table, and existing records receive the default value of true. Document the exact migration command used.",
            "status": "done",
            "testStrategy": "Query the database to confirm the column exists with correct type and default value. Verify existing records have isBlocked=true. Test inserting new records to ensure default value is applied"
          },
          {
            "id": 4,
            "title": "Implement backward compatibility handling",
            "description": "Add code to handle potential null values during the transition period and ensure application stability",
            "dependencies": [
              "1.2",
              "1.3"
            ],
            "details": "Update data access layer and API endpoints to safely handle cases where isBlocked might be null or undefined. Add defensive programming checks and default value fallbacks. Consider adding a data migration script to backfill any null values if needed.",
            "status": "done",
            "testStrategy": "Test application behavior with both old records (potentially null isBlocked) and new records. Verify API responses always include isBlocked field with boolean value. Test edge cases where field might be missing"
          },
          {
            "id": 5,
            "title": "Execute migration in staging and prepare for production",
            "description": "Run the migration in staging environment, test thoroughly, and prepare rollback procedures for production deployment",
            "dependencies": [
              "1.3",
              "1.4"
            ],
            "details": "Execute migration in staging environment following the same process as development. Document the exact steps, timing, and any issues encountered. Prepare a rollback script and test it in a separate environment. Create a deployment checklist for production migration.",
            "status": "done",
            "testStrategy": "Perform full regression testing in staging. Test rollback procedure in a test environment. Verify performance impact of the new column. Validate that all API endpoints handle the new field correctly"
          }
        ]
      },
      {
        "id": 2,
        "title": "Update Site Blocker Service Layer",
        "description": "Modify the site blocker service to handle the new isBlocked field in all CRUD operations and add filtering capabilities",
        "details": "1. Update createSiteBlocker to set isBlocked: true by default\n2. Modify getSiteBlockers to include isBlocked in response\n3. Add query parameter filtering: ?isBlocked=true/false\n4. Update updateSiteBlocker to handle isBlocked changes\n5. Ensure all DTOs and response types include isBlocked field",
        "testStrategy": "1. Unit test createSiteBlocker with and without explicit isBlocked\n2. Test getSiteBlockers returns isBlocked field\n3. Verify filtering works correctly with isBlocked parameter\n4. Test edge cases with null/undefined values\n5. Integration test with actual database",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update createSiteBlocker Service Method",
            "description": "Modify the createSiteBlocker method in the site blocker service to set isBlocked: true by default when creating new site blockers",
            "dependencies": [],
            "details": "Update the service method to include isBlocked: true in the site blocker creation payload. Ensure the method accepts an optional isBlocked parameter but defaults to true if not provided. Update the corresponding DTO to include the isBlocked field.",
            "status": "done",
            "testStrategy": "Write unit tests to verify that createSiteBlocker sets isBlocked to true by default, test explicit isBlocked: false creation, and ensure the response includes the isBlocked field"
          },
          {
            "id": 2,
            "title": "Modify getSiteBlockers with Filtering",
            "description": "Update the getSiteBlockers service method to include isBlocked in responses and implement query parameter filtering for isBlocked status",
            "dependencies": [],
            "details": "Modify the getSiteBlockers method to ensure isBlocked field is included in all returned site blocker objects. Implement query parameter parsing to accept ?isBlocked=true/false and filter results accordingly. Handle edge cases where the parameter is not provided.",
            "status": "done",
            "testStrategy": "Test that getSiteBlockers returns isBlocked field for all items, verify filtering works with isBlocked=true, isBlocked=false, and when parameter is omitted"
          },
          {
            "id": 3,
            "title": "Update updateSiteBlocker Method",
            "description": "Enhance the updateSiteBlocker service method to handle updates to the isBlocked field",
            "dependencies": [],
            "details": "Modify updateSiteBlocker to accept isBlocked in the update payload. Ensure proper validation and that the updated isBlocked value is persisted and returned in the response. Handle partial updates where isBlocked might not be included.",
            "status": "done",
            "testStrategy": "Test updating isBlocked from true to false and vice versa, test partial updates without isBlocked field, verify response includes updated isBlocked value"
          },
          {
            "id": 4,
            "title": "Update DTOs and Response Types",
            "description": "Update all Data Transfer Objects and TypeScript response types to include the isBlocked field throughout the service layer",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3"
            ],
            "details": "Add isBlocked: boolean to CreateSiteBlockerDto, UpdateSiteBlockerDto, and SiteBlockerResponseDto. Ensure all TypeScript interfaces and types used in the service layer include the isBlocked field. Update any validation schemas if applicable.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation passes with updated types, test that all CRUD operations properly serialize/deserialize the isBlocked field"
          },
          {
            "id": 5,
            "title": "Add Service Layer Integration Tests",
            "description": "Create comprehensive integration tests for all site blocker service methods with the new isBlocked functionality",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.4"
            ],
            "details": "Write integration tests that cover the complete flow: create with default isBlocked, get with filtering, update isBlocked status, and verify data persistence. Test edge cases including null/undefined values and ensure backward compatibility.",
            "status": "done",
            "testStrategy": "Test full CRUD cycle with isBlocked field, verify database persistence, test filtering combinations, ensure no regression in existing functionality"
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Toggle Endpoint",
        "description": "Create PUT /api/site-blockers/:id/toggle endpoint to flip the isBlocked state of a specific site blocker",
        "details": "1. Create route handler: PUT /api/site-blockers/:id/toggle\n2. Implement toggle logic: fetch current state, flip boolean, save\n3. Add proper validation and error handling\n4. Return updated site blocker with new isBlocked state\n5. Add rate limiting to prevent abuse\n6. Implement proper authorization checks",
        "testStrategy": "1. Test successful toggle from true to false and vice versa\n2. Test with invalid site blocker ID (404 response)\n3. Test authorization (user can only toggle their own blockers)\n4. Test concurrent toggle requests\n5. Verify response includes updated isBlocked value",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Route Handler Structure",
            "description": "Set up the PUT /api/site-blockers/:id/toggle endpoint with proper routing and middleware configuration",
            "dependencies": [],
            "details": "Create the route handler file, configure Express/Next.js routing to handle PUT requests at /api/site-blockers/:id/toggle, set up proper middleware chain including authentication, CORS, and body parsing",
            "status": "pending",
            "testStrategy": "Test that the route responds to PUT requests, returns 401 for unauthenticated requests, properly extracts the ID parameter from the URL"
          },
          {
            "id": 2,
            "title": "Implement Authorization and Validation",
            "description": "Add authorization checks to ensure users can only toggle their own site blockers and validate the provided ID",
            "dependencies": [
              "3.1"
            ],
            "details": "Extract user ID from authentication token, validate that the site blocker ID exists and belongs to the authenticated user, return 404 for non-existent blockers and 403 for unauthorized access attempts",
            "status": "pending",
            "testStrategy": "Test with valid user/blocker combinations, test with invalid blocker IDs, test attempts to toggle other users' blockers, verify proper error codes and messages"
          },
          {
            "id": 3,
            "title": "Implement Toggle Logic and Database Update",
            "description": "Create the core toggle functionality that fetches the current state, flips the boolean value, and persists the change",
            "dependencies": [
              "3.2"
            ],
            "details": "Fetch the current site blocker from database, flip the isBlocked boolean value, update the database record with the new state, handle database errors gracefully with proper rollback",
            "status": "pending",
            "testStrategy": "Test toggling from true to false and vice versa, test database update success, test handling of database connection errors, verify the state change is persisted"
          },
          {
            "id": 4,
            "title": "Add Rate Limiting Middleware",
            "description": "Implement rate limiting to prevent abuse of the toggle endpoint",
            "dependencies": [
              "3.1"
            ],
            "details": "Configure rate limiting middleware (e.g., express-rate-limit) with appropriate limits per user/IP, set reasonable time windows and request limits, return 429 status code when limit exceeded with retry-after header",
            "status": "pending",
            "testStrategy": "Test normal usage stays under limits, test rapid requests trigger rate limiting, verify rate limit resets after time window, test different users have separate limits"
          },
          {
            "id": 5,
            "title": "Format Response and Error Handling",
            "description": "Ensure the endpoint returns properly formatted responses with the updated site blocker data and comprehensive error handling",
            "dependencies": [
              "3.3"
            ],
            "details": "Return the complete updated site blocker object with new isBlocked state, implement consistent error response format, add logging for debugging and monitoring, include appropriate HTTP status codes for all scenarios",
            "status": "pending",
            "testStrategy": "Test successful response includes all site blocker fields with updated isBlocked value, test error responses have consistent format, verify all edge cases return appropriate status codes"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Bulk Toggle Endpoint",
        "description": "Create PUT /api/site-blockers/bulk-toggle endpoint to update multiple site blockers' isBlocked state in a single request",
        "details": "1. Create route: PUT /api/site-blockers/bulk-toggle\n2. Accept body: { ids: string[], isBlocked: boolean }\n3. Validate all IDs belong to authenticated user\n4. Use transaction for atomic updates\n5. Return array of updated site blockers\n6. Handle partial failures gracefully",
        "testStrategy": "1. Test bulk update with valid IDs\n2. Test with mix of valid and invalid IDs\n3. Test transaction rollback on error\n4. Test authorization (cannot update other users' blockers)\n5. Performance test with large ID arrays",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Bulk Toggle Route Handler",
            "description": "Set up the PUT /api/site-blockers/bulk-toggle endpoint with proper routing and middleware",
            "dependencies": [],
            "details": "1. Create new route file for bulk operations if not exists\n2. Define PUT route at /api/site-blockers/bulk-toggle\n3. Add authentication middleware to protect the endpoint\n4. Set up request body validation middleware\n5. Configure rate limiting for bulk operations",
            "status": "pending",
            "testStrategy": "1. Test route registration and accessibility\n2. Test authentication requirement (401 for unauthenticated)\n3. Test rate limiting behavior\n4. Verify proper HTTP method handling"
          },
          {
            "id": 2,
            "title": "Implement Request Validation",
            "description": "Create validation logic for the bulk toggle request body to ensure data integrity",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Validate request body structure: { ids: string[], isBlocked: boolean }\n2. Check ids array is not empty and contains valid UUIDs\n3. Verify isBlocked is a boolean value\n4. Add maximum array size limit (e.g., 100 IDs)\n5. Return 400 Bad Request with descriptive errors for validation failures",
            "status": "pending",
            "testStrategy": "1. Test with valid request body\n2. Test with missing or invalid ids array\n3. Test with non-boolean isBlocked values\n4. Test with empty ids array\n5. Test with excessive array size"
          },
          {
            "id": 3,
            "title": "Implement Authorization Logic",
            "description": "Verify that all provided site blocker IDs belong to the authenticated user before processing",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Extract user ID from authenticated session\n2. Query database to verify all IDs exist and belong to user\n3. Collect any invalid or unauthorized IDs\n4. Return 403 Forbidden if any IDs don't belong to user\n5. Return 404 Not Found for non-existent IDs",
            "status": "pending",
            "testStrategy": "1. Test with all valid user-owned IDs\n2. Test with mix of owned and other users' IDs\n3. Test with non-existent IDs\n4. Test authorization error response format"
          },
          {
            "id": 4,
            "title": "Implement Transactional Bulk Update",
            "description": "Create the core logic to update multiple site blockers within a database transaction",
            "dependencies": [
              "4.3"
            ],
            "details": "1. Start database transaction\n2. Perform bulk update query for all valid IDs\n3. Set isBlocked field to provided value\n4. Track successfully updated records\n5. Commit transaction on success, rollback on any error\n6. Return array of updated site blocker objects",
            "status": "pending",
            "testStrategy": "1. Test successful bulk update of multiple records\n2. Test transaction rollback on database error\n3. Test with concurrent update attempts\n4. Verify all records updated atomically"
          },
          {
            "id": 5,
            "title": "Handle Partial Failures and Response",
            "description": "Implement graceful handling of partial failures and format the API response",
            "dependencies": [
              "4.4"
            ],
            "details": "1. Track which IDs were successfully updated\n2. Identify any IDs that failed (unauthorized, not found)\n3. Structure response: { updated: SiteBlocker[], failed: { id: string, reason: string }[] }\n4. Return 207 Multi-Status for partial success\n5. Return 200 OK if all updates successful\n6. Include proper error messages for failed items",
            "status": "pending",
            "testStrategy": "1. Test response with all successful updates\n2. Test response with some failures\n3. Test response format consistency\n4. Verify HTTP status codes\n5. Test error message clarity"
          }
        ]
      },
      {
        "id": 5,
        "title": "Update Extension Storage Interfaces",
        "description": "Modify Chrome extension's TypeScript interfaces and storage structure to include isBlocked field while maintaining backward compatibility",
        "details": "1. Update SiteBlockState interface:\ninterface SiteBlockState {\n  id: string;\n  url: string;\n  isBlocked: boolean;\n  blocked?: boolean; // deprecated\n  streak: number;\n  createdAt: number;\n}\n2. Create migration logic for existing storage data\n3. Map blocked -> isBlocked for backward compatibility\n4. Update all storage read/write operations\n5. Add version tracking for storage schema",
        "testStrategy": "1. Test storage migration with existing data\n2. Verify backward compatibility with old field\n3. Test new installations start with correct schema\n4. Test storage limits aren't exceeded\n5. Verify data integrity after migration",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update SiteBlockState Interface",
            "description": "Modify the TypeScript interface to include the new isBlocked field while maintaining backward compatibility with the deprecated blocked field",
            "dependencies": [],
            "details": "Update the SiteBlockState interface in the Chrome extension's type definitions to include both isBlocked (boolean) and blocked (boolean, deprecated) fields. Ensure proper TypeScript typing and add JSDoc comments to mark blocked as deprecated. Update any related type exports and ensure the interface is properly exported for use throughout the extension.",
            "status": "done",
            "testStrategy": "1. Verify TypeScript compilation succeeds with new interface\n2. Test that both old and new field types are accepted\n3. Check that TypeScript IntelliSense shows deprecation warning for blocked field\n4. Ensure no type errors in consuming components\n5. Validate interface compatibility with existing storage data"
          },
          {
            "id": 2,
            "title": "Implement Storage Migration Logic",
            "description": "Create migration function to convert existing storage data from blocked to isBlocked field format while preserving all existing data",
            "dependencies": [
              "5.1"
            ],
            "details": "Develop a migration function that reads existing storage data, checks for the presence of blocked field without isBlocked, and performs the mapping (isBlocked = blocked). Implement version tracking in storage to prevent re-migration. Handle edge cases like undefined/null values and ensure migration runs only once per installation. Include error handling and fallback mechanisms.",
            "status": "done",
            "testStrategy": "1. Test migration with various existing data formats\n2. Verify data integrity after migration (no data loss)\n3. Test migration doesn't run twice on same data\n4. Test handling of corrupted or incomplete data\n5. Verify performance with large datasets"
          },
          {
            "id": 3,
            "title": "Update Storage Read Operations",
            "description": "Modify all Chrome storage read operations to handle both isBlocked and blocked fields with proper fallback logic",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "Update all chrome.storage.sync.get() and chrome.storage.local.get() calls to read the isBlocked field. Implement fallback logic to check blocked field if isBlocked is undefined. Create utility functions for consistent field access across the extension. Update any caching mechanisms to work with the new field structure.",
            "status": "done",
            "testStrategy": "1. Test reading data with only isBlocked field\n2. Test reading data with only blocked field (backward compatibility)\n3. Test reading data with both fields present\n4. Verify correct precedence (isBlocked over blocked)\n5. Test error handling for storage read failures"
          },
          {
            "id": 4,
            "title": "Update Storage Write Operations",
            "description": "Modify all Chrome storage write operations to save data using the isBlocked field while maintaining backward compatibility",
            "dependencies": [
              "5.1",
              "5.3"
            ],
            "details": "Update all chrome.storage.sync.set() and chrome.storage.local.set() calls to write the isBlocked field. Ensure new entries only write isBlocked (not blocked). Update bulk operations and partial updates to handle the new field correctly. Implement storage quota management considering the additional field.",
            "status": "done",
            "testStrategy": "1. Test creating new entries with isBlocked field only\n2. Test updating existing entries preserves other fields\n3. Test bulk operations with mixed old/new formats\n4. Verify storage quota limits are respected\n5. Test write operation error handling and retries"
          },
          {
            "id": 5,
            "title": "Add Storage Schema Versioning",
            "description": "Implement version tracking system for storage schema to manage future migrations and ensure data consistency",
            "dependencies": [
              "5.2",
              "5.4"
            ],
            "details": "Create a storage schema versioning system that tracks the current schema version in chrome.storage. Implement version comparison logic and migration registry for future updates. Add initialization code to set version on first install. Include debug utilities to inspect current schema version and migration history.",
            "status": "done",
            "testStrategy": "1. Test version initialization on fresh install\n2. Test version detection on existing installations\n3. Verify version updates after migration\n4. Test rollback scenarios and version conflicts\n5. Validate version persistence across browser restarts"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement API Sync Logic in Extension",
        "description": "Create synchronization mechanism between Chrome extension and API to keep isBlocked state consistent across both systems",
        "details": "1. On extension load: fetch all site blockers from API\n2. Merge API data with local storage (API as source of truth)\n3. Implement sync function for state changes:\n   - On toggle: update local immediately, queue API call\n   - Handle API response and rollback on failure\n4. Add periodic sync (every 5 minutes)\n5. Implement conflict resolution strategy",
        "testStrategy": "1. Test initial sync on extension load\n2. Test real-time sync on toggle action\n3. Test offline behavior and queue\n4. Test conflict resolution (local vs remote changes)\n5. Test sync performance with large datasets",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Sync Service and Data Fetching",
            "description": "Implement core sync service class with API client for fetching site blockers from the backend on extension initialization",
            "dependencies": [],
            "details": "Create SyncService class with methods: fetchAllSiteBlockers() to retrieve data from /api/site-blockers endpoint, initializeSync() to set up the service on extension load, and proper error handling for network failures. Implement authentication token management for API calls.",
            "status": "pending",
            "testStrategy": "Mock API responses for successful fetch, test network error handling, verify authentication headers are properly set, test data transformation from API format to extension storage format"
          },
          {
            "id": 2,
            "title": "Implement Local Storage Merge Logic",
            "description": "Create merge algorithm to reconcile API data with local Chrome storage, treating API as source of truth while preserving local queue items",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement mergeWithLocal() method that: compares API response with chrome.storage.local data, preserves unsynced local changes in queue, updates local storage with API data, handles conflicts by prioritizing API state, and maintains data integrity during merge process.",
            "status": "pending",
            "testStrategy": "Test merge with conflicting states, verify API data overwrites local except for queued items, test edge cases with empty datasets, verify no data loss during merge operation"
          },
          {
            "id": 3,
            "title": "Build Real-time State Change Sync",
            "description": "Implement immediate local update with queued API synchronization for toggle actions, including optimistic updates and rollback mechanism",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Create syncToggle() method that: updates local state immediately for responsive UI, queues API call to /api/site-blockers/:id/toggle, handles successful response by confirming local state, implements rollback on API failure, and integrates with offline queue for network issues.",
            "status": "pending",
            "testStrategy": "Test optimistic update flow, verify rollback on API failure, test queue integration during offline state, verify UI reflects immediate changes, test concurrent toggle handling"
          },
          {
            "id": 4,
            "title": "Implement Periodic Background Sync",
            "description": "Set up Chrome alarms API for periodic synchronization every 5 minutes to ensure data consistency between extension and backend",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Configure chrome.alarms to trigger sync every 5 minutes, implement background script handler for alarm events, create periodicSync() method that fetches latest data and merges, handle sync conflicts during background sync, and implement sync status tracking.",
            "status": "pending",
            "testStrategy": "Test alarm creation and firing, verify sync runs in background, test conflict resolution during periodic sync, measure performance impact, test sync recovery after errors"
          },
          {
            "id": 5,
            "title": "Create Conflict Resolution Strategy",
            "description": "Develop comprehensive conflict resolution system for handling discrepancies between local and remote state during various sync scenarios",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Implement ConflictResolver class with strategies for: timestamp-based resolution for concurrent changes, handling deleted items on either side, resolving bulk updates vs individual toggles, managing sync conflicts during offline recovery, and providing user feedback for unresolvable conflicts.",
            "status": "pending",
            "testStrategy": "Test concurrent modification scenarios, verify timestamp comparison logic, test deletion conflict handling, simulate offline changes with server updates, verify user notifications for conflicts"
          }
        ]
      },
      {
        "id": 7,
        "title": "Add Offline Queue Handling",
        "description": "Implement offline queue system to handle API sync operations when the extension is offline and process them when connection is restored",
        "details": "1. Create OfflineQueue class with Chrome storage backend\n2. Queue structure: { action: 'toggle', id: string, timestamp: number }\n3. Detect online/offline state using navigator.onLine\n4. Process queue on connection restore\n5. Implement retry logic with exponential backoff\n6. Clear processed items and handle failures",
        "testStrategy": "1. Test queue persistence across extension restarts\n2. Test queue processing on connection restore\n3. Test deduplication of queued actions\n4. Test queue size limits and cleanup\n5. Test retry behavior on API failures",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create OfflineQueue Class with Chrome Storage",
            "description": "Implement the core OfflineQueue class that uses Chrome's storage API as the persistence backend for queued operations",
            "dependencies": [],
            "details": "Create OfflineQueue.ts class with methods: enqueue(), dequeue(), peek(), clear(), getAll(). Use chrome.storage.local for persistence with key 'offlineQueue'. Implement queue item interface: { id: string, action: 'toggle', targetId: string, timestamp: number, retryCount: number }. Add singleton pattern to ensure single instance across extension.",
            "status": "pending",
            "testStrategy": "Test queue persistence by adding items and verifying they survive extension reload. Test FIFO ordering. Test storage limits handling. Mock chrome.storage API for unit tests."
          },
          {
            "id": 2,
            "title": "Implement Online/Offline Detection System",
            "description": "Create a robust connection state detection system that monitors network availability and triggers queue processing",
            "dependencies": [
              "7.1"
            ],
            "details": "Create ConnectionMonitor class using navigator.onLine and online/offline events. Add periodic connectivity checks using fetch to API health endpoint. Implement state change callbacks. Add debouncing to prevent rapid state changes. Store last known connection state in chrome.storage.",
            "status": "pending",
            "testStrategy": "Test detection with network disconnection simulation. Test event listener cleanup. Verify debouncing prevents queue processing thrashing. Test false positive handling when navigator.onLine is true but API is unreachable."
          },
          {
            "id": 3,
            "title": "Build Queue Processing Engine with Retry Logic",
            "description": "Implement the queue processor that handles dequeuing and executing operations with exponential backoff retry mechanism",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Create QueueProcessor class with processQueue() method. Implement exponential backoff: delays of 1s, 2s, 4s, 8s, max 30s. Add maximum retry limit of 5 attempts. Process items sequentially to maintain order. Update retry count on failures. Move failed items to dead letter queue after max retries.",
            "status": "pending",
            "testStrategy": "Test successful processing of queued items. Test retry delays follow exponential pattern. Test dead letter queue for permanently failed items. Test queue processing stops on offline detection."
          },
          {
            "id": 4,
            "title": "Integrate Queue System with Toggle Operations",
            "description": "Connect the offline queue to the existing site blocker toggle functionality in the Chrome extension",
            "dependencies": [
              "7.3"
            ],
            "details": "Modify toggle handler to check connection state first. If offline, enqueue operation and update UI optimistically. If online, attempt direct API call with fallback to queue on failure. Add queue status indicator to UI. Implement deduplication logic to prevent duplicate toggles for same site.",
            "status": "pending",
            "testStrategy": "Test toggle operation queuing when offline. Test immediate execution when online. Test deduplication prevents multiple toggles for same site. Test UI reflects queued state accurately."
          },
          {
            "id": 5,
            "title": "Add Queue Management and Monitoring Features",
            "description": "Implement administrative features for monitoring and managing the offline queue including cleanup and status reporting",
            "dependencies": [
              "7.4"
            ],
            "details": "Add queue size limit (max 100 items) with FIFO eviction. Create queue status API: getQueueSize(), getQueueStatus(), clearQueue(). Add chrome.alarms for periodic cleanup of old items (>24 hours). Implement queue metrics: success rate, average retry count. Add debug mode for queue inspection.",
            "status": "pending",
            "testStrategy": "Test queue size limits and eviction. Test periodic cleanup removes stale items. Test metrics calculation accuracy. Test manual queue clearing. Verify queue status updates in real-time."
          }
        ]
      },
      {
        "id": 8,
        "title": "Update Content Script Blocker Logic",
        "description": "Modify content.tsx to check isBlocked field instead of blocked field when determining whether to show the blocking overlay",
        "details": "1. Update checkIfBlocked function to use isBlocked field\n2. Maintain fallback to blocked field for compatibility\n3. Ensure overlay only shows when isBlocked === true\n4. Add debug logging for state transitions\n5. Optimize storage queries for performance",
        "testStrategy": "1. Test blocking works with isBlocked: true\n2. Test no blocking with isBlocked: false\n3. Test fallback to old blocked field\n4. Test performance with many blocked sites\n5. Verify no console errors in production",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Locate and analyze content.tsx file",
            "description": "Find the content.tsx file in the Chrome extension codebase and analyze the current checkIfBlocked function implementation to understand how it currently checks the blocked field",
            "dependencies": [],
            "details": "Search for content.tsx in the extension directory, identify the checkIfBlocked function, understand current logic flow, document all places where the blocked field is referenced, and analyze how the blocking overlay is triggered",
            "status": "pending",
            "testStrategy": "Verify file exists, document current function behavior, create test cases for existing functionality before modification"
          },
          {
            "id": 2,
            "title": "Update checkIfBlocked function to use isBlocked field",
            "description": "Modify the checkIfBlocked function to primarily check the isBlocked field when determining whether to show the blocking overlay, while maintaining backward compatibility",
            "dependencies": [
              "8.1"
            ],
            "details": "Update field check from 'blocked' to 'isBlocked', implement fallback logic: if (site.isBlocked !== undefined ? site.isBlocked : site.blocked), ensure overlay triggers only when isBlocked === true explicitly, handle edge cases where both fields might exist",
            "status": "pending",
            "testStrategy": "Test with isBlocked: true shows overlay, isBlocked: false hides overlay, undefined isBlocked falls back to blocked field, both fields present prioritizes isBlocked"
          },
          {
            "id": 3,
            "title": "Add debug logging for state transitions",
            "description": "Implement comprehensive debug logging throughout the content script to track when and why the blocking state changes, helping diagnose issues in production",
            "dependencies": [
              "8.2"
            ],
            "details": "Add console.debug statements for: initial site check, field values (isBlocked vs blocked), state transitions, overlay show/hide decisions, storage query timings, include timestamps and site URL in logs, use conditional logging based on environment",
            "status": "pending",
            "testStrategy": "Verify logs appear in development mode, ensure no logs in production builds, test log output contains useful debugging information, verify no performance impact from logging"
          },
          {
            "id": 4,
            "title": "Optimize storage queries for performance",
            "description": "Improve the performance of Chrome storage queries in the content script to reduce latency when checking if a site is blocked, especially for users with many blocked sites",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "Implement caching strategy for frequently checked sites, batch storage reads where possible, use chrome.storage.local instead of sync for performance-critical data, implement debouncing for rapid URL changes, minimize storage reads by storing active block states in memory",
            "status": "pending",
            "testStrategy": "Benchmark storage query times before and after optimization, test with 100+ blocked sites, verify cache invalidation works correctly, ensure memory usage stays reasonable, test performance on tab switching"
          },
          {
            "id": 5,
            "title": "Update all references to blocked field in content script",
            "description": "Ensure all other parts of the content script that reference the blocked field are updated to use isBlocked, maintaining consistency throughout the codebase",
            "dependencies": [
              "8.1",
              "8.2"
            ],
            "details": "Search for all occurrences of 'blocked' field in content.tsx and related files, update each reference to use isBlocked with fallback, update any TypeScript interfaces or types used in content script, ensure message passing between content script and background script uses correct field names",
            "status": "pending",
            "testStrategy": "Grep for all 'blocked' field references and verify updates, test all functionality that depends on blocking state, verify no TypeScript errors after changes, test message passing with new field names"
          }
        ]
      },
      {
        "id": 9,
        "title": "Add Toggle UI in Extension Popup",
        "description": "Create toggle switch UI component in the extension popup to allow users to quickly enable/disable blocking for each site",
        "details": "1. Add toggle switch component (use existing UI library)\n2. Show isBlocked state for each site in list\n3. Visual indicators: green (active), gray (inactive)\n4. Optimistic UI updates with rollback on failure\n5. Add loading states during API sync\n6. Implement debouncing for rapid toggles",
        "testStrategy": "1. Test toggle switch updates local state immediately\n2. Test visual feedback during API sync\n3. Test error handling and rollback\n4. Test accessibility (keyboard navigation)\n5. Test UI with many sites (scrolling, performance)",
        "priority": "medium",
        "dependencies": [
          6,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Toggle Switch Component",
            "description": "Build a reusable toggle switch component for the extension popup that matches the existing UI design system",
            "dependencies": [],
            "details": "1. Create ToggleSwitch.tsx component in extensions/components folder\n2. Use existing UI library components (likely Material-UI or similar)\n3. Implement props: isChecked, onChange, disabled, loading\n4. Add smooth transition animations for state changes\n5. Ensure proper ARIA labels for accessibility\n6. Style with green for active, gray for inactive states",
            "status": "pending",
            "testStrategy": "1. Test component renders with correct initial state\n2. Test onChange callback fires with correct value\n3. Test disabled state prevents interaction\n4. Test loading state shows appropriate indicator\n5. Test keyboard navigation (space/enter keys)\n6. Test screen reader announces state changes"
          },
          {
            "id": 2,
            "title": "Integrate Toggle with Site List",
            "description": "Add toggle switches to each site entry in the popup's site list, connecting them to the site blocker data",
            "dependencies": [
              "9.1"
            ],
            "details": "1. Update SiteListItem component to include ToggleSwitch\n2. Pass isBlocked prop from site blocker state\n3. Position toggle on the right side of each list item\n4. Ensure toggle doesn't interfere with other site actions\n5. Add hover states and visual feedback\n6. Maintain list scrollability with many items",
            "status": "pending",
            "testStrategy": "1. Test toggle displays correct state for each site\n2. Test list renders properly with 50+ sites\n3. Test toggle click doesn't trigger row click\n4. Test visual layout on different screen sizes\n5. Test performance with rapid scrolling"
          },
          {
            "id": 3,
            "title": "Implement Optimistic Updates",
            "description": "Add optimistic UI updates with automatic rollback on API failures to ensure responsive user experience",
            "dependencies": [
              "9.2"
            ],
            "details": "1. Update local state immediately on toggle click\n2. Queue API request to sync with backend\n3. Store previous state for rollback capability\n4. Implement error boundary for failed updates\n5. Show subtle loading indicator during sync\n6. Display error toast on sync failure with retry option",
            "status": "pending",
            "testStrategy": "1. Test immediate UI update on toggle click\n2. Test rollback when API returns error\n3. Test multiple rapid toggles queue properly\n4. Test network failure handling\n5. Test state consistency after errors\n6. Test retry mechanism works correctly"
          },
          {
            "id": 4,
            "title": "Add Debouncing Logic",
            "description": "Implement debouncing mechanism to handle rapid toggle clicks and prevent excessive API calls",
            "dependencies": [
              "9.3"
            ],
            "details": "1. Create useDebounce hook with 500ms delay\n2. Apply debouncing to toggle state changes\n3. Cancel pending API calls when new toggle occurs\n4. Batch multiple toggles within debounce window\n5. Ensure final state always syncs with backend\n6. Add visual feedback for pending changes",
            "status": "pending",
            "testStrategy": "1. Test rapid clicks only trigger one API call\n2. Test final state matches last user action\n3. Test cancellation of in-flight requests\n4. Test debounce timer resets on new input\n5. Test edge case of component unmount during debounce"
          },
          {
            "id": 5,
            "title": "Implement Loading States and Error Handling",
            "description": "Add comprehensive loading indicators and error handling for toggle operations with user-friendly feedback",
            "dependencies": [
              "9.4"
            ],
            "details": "1. Add loading spinner overlay on toggle during sync\n2. Implement global loading state for bulk operations\n3. Create error notification system with retry options\n4. Add connection status indicator\n5. Handle offline mode gracefully\n6. Implement exponential backoff for retries",
            "status": "pending",
            "testStrategy": "1. Test loading spinner appears during API calls\n2. Test error messages are clear and actionable\n3. Test offline mode shows appropriate message\n4. Test retry mechanism with backoff\n5. Test multiple simultaneous toggle operations\n6. Test accessibility of loading/error states"
          }
        ]
      },
      {
        "id": 10,
        "title": "Add User Notification System",
        "description": "Implement notification system to inform users about important state changes and guide them through the blocking process",
        "details": "1. Create notification when site is added: 'Site will be blocked on next visit'\n2. Add refresh prompt for already-open tabs\n3. Show sync status notifications (syncing, synced, offline)\n4. Implement Chrome notifications API\n5. Add settings to control notification preferences\n6. Include quick action buttons in notifications",
        "testStrategy": "1. Test notification appears when adding new site\n2. Test notification permissions handling\n3. Test notification click actions\n4. Test notification preferences persistence\n5. Verify notifications don't spam users",
        "priority": "low",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Chrome Notifications API permissions and manifest",
            "description": "Configure Chrome extension manifest to request notifications permission and set up the basic notification infrastructure",
            "dependencies": [],
            "details": "Update manifest.json to include 'notifications' permission. Create a notifications service module that handles permission checks and provides a centralized interface for creating notifications. Implement permission request flow if not already granted.",
            "status": "pending",
            "testStrategy": "Test manifest changes load correctly, verify permission request flow works, test fallback behavior when permission is denied"
          },
          {
            "id": 2,
            "title": "Implement site addition notification system",
            "description": "Create notification when a new site is added to the block list, informing users that the site will be blocked on next visit",
            "dependencies": [
              "10.1"
            ],
            "details": "Hook into the site addition flow to trigger a notification. Display message: 'Site will be blocked on next visit'. Include the site domain in the notification. Add action buttons for 'Undo' and 'Refresh Now'. Handle notification click to focus the extension popup.",
            "status": "pending",
            "testStrategy": "Test notification appears when adding sites via popup and context menu, verify undo action removes the site, test refresh action reloads affected tabs"
          },
          {
            "id": 3,
            "title": "Build sync status notification system",
            "description": "Implement notifications for sync operations including syncing, synced, and offline states",
            "dependencies": [
              "10.1"
            ],
            "details": "Create listeners for sync events from the API sync logic. Show brief notifications for: sync started, sync completed successfully, sync failed/offline mode. Include retry action for failed syncs. Implement debouncing to prevent notification spam during rapid sync events.",
            "status": "pending",
            "testStrategy": "Test notifications appear for each sync state, verify debouncing prevents spam, test offline detection and retry functionality"
          },
          {
            "id": 4,
            "title": "Create refresh prompt for already-open tabs",
            "description": "Implement a system to notify users when they have tabs open for newly blocked sites",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "When a site is added to block list, check all open tabs for matching URLs. Show notification: 'You have X tab(s) open for [domain]. Refresh to apply blocking.' Add 'Refresh All' action button. Implement tab refresh logic that maintains tab positions and groups.",
            "status": "pending",
            "testStrategy": "Test detection of matching tabs across multiple windows, verify refresh maintains tab state, test with various URL patterns and subdomains"
          },
          {
            "id": 5,
            "title": "Add notification preferences to settings",
            "description": "Implement settings UI and storage for users to control which notifications they receive",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3",
              "10.4"
            ],
            "details": "Add notification preferences section to extension settings. Include toggles for: site addition notifications, sync status notifications, open tab prompts. Store preferences in Chrome storage sync. Apply preferences to all notification triggers. Set sensible defaults (all enabled except sync status).",
            "status": "pending",
            "testStrategy": "Test preference toggles persist across sessions, verify disabled notifications don't appear, test settings sync across devices"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-26T09:27:38.438Z",
      "updated": "2025-07-26T09:58:56.983Z",
      "description": "Tasks for master context"
    }
  }
}